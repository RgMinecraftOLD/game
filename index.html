<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Mini Minecraft iOS</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
body { margin:0; overflow:hidden; background:#000; touch-action:none; }
#crosshair {
 position:fixed;
 left:50%;
 top:50%;
 transform:translate(-50%,-50%);
 color:white;
 font-size:24px;
 pointer-events:none;
}
#ui {
 position:fixed;
 bottom:20px;
 left:50%;
 transform:translateX(-50%);
 color:white;
 font-family:sans-serif;
 background:rgba(0,0,0,0.5);
 padding:10px 20px;
 border-radius:10px;
}
</style>
</head>
<body>

<div id="crosshair">+</div>
<div id="ui">Свайп — смотреть | Тап — ломать | Два пальца — ставить</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 2, 6);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.DirectionalLight(0xffffff,1));
scene.add(new THREE.AmbientLight(0xffffff,0.6));

const world = [];
const geo = new THREE.BoxGeometry(1,1,1);
const mat = new THREE.MeshLambertMaterial({color:0x55aa55});

function addBlock(x,y,z){
 const b = new THREE.Mesh(geo, mat);
 b.position.set(x,y,z);
 scene.add(b);
 world.push(b);
}

for(let x=-8;x<=8;x++){
 for(let z=-8;z<=8;z++){
   addBlock(x,0,z);
 }
}

let rotX = -0.4, rotY = 0;

let touching = false;
let lastX = 0, lastY = 0;

document.addEventListener("touchstart", e=>{
 touching = true;
 lastX = e.touches[0].clientX;
 lastY = e.touches[0].clientY;
});

document.addEventListener("touchmove", e=>{
 if(!touching) return;
 const x = e.touches[0].clientX;
 const y = e.touches[0].clientY;

 const dx = x - lastX;
 const dy = y - lastY;
 lastX = x;
 lastY = y;

 rotY -= dx * 0.005;
 rotX -= dy * 0.005;
 rotX = Math.max(-1.5, Math.min(1.5, rotX));

 camera.rotation.set(rotX, rotY, 0);
});

document.addEventListener("touchend", ()=> touching = false);

const raycaster = new THREE.Raycaster();

document.addEventListener("touchstart", e=>{
 if(e.touches.length === 1){
   raycaster.setFromCamera({x:0,y:0}, camera);
   const hits = raycaster.intersectObjects(world);
   if(hits.length){
     const obj = hits[0].object;
     scene.remove(obj);
     world.splice(world.indexOf(obj),1);
   }
 }

 if(e.touches.length === 2){
   raycaster.setFromCamera({x:0,y:0}, camera);
   const hits = raycaster.intersectObjects(world);
   if(hits.length){
     const p = hits[0].point.clone().add(hits[0].face.normal);
     addBlock(Math.round(p.x), Math.round(p.y), Math.round(p.z));
   }
 }
});

function animate(){
 requestAnimationFrame(animate);
 renderer.render(scene, camera);
}
animate();

onresize = ()=>{
 camera.aspect = innerWidth/innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth, innerHeight);
};
</script>
</body>
</html>
